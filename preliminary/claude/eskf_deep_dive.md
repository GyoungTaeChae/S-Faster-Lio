# ESKF 심층 분석: f, F, Fw의 관계

S-Faster-Lio의 Error State Kalman Filter 구현을 분석하면서 정리한 핵심 개념들.

---

## 1. f 벡터와 F 행렬의 관계

### 핵심 개념

- **f**: 상태의 시간 변화율을 계산하는 함수 (f(x, u) = ẋ)
- **F**: f를 상태에 대해 편미분한 야코비 행렬 (F = ∂f/∂x)

### f 벡터란?

```
f(x, u) = ẋ = 상태의 시간 변화율
```

f는 현재 상태 x와 입력 u가 주어졌을 때, **상태가 시간에 따라 어떻게 변하는지**를 계산하는 함수.

### f 벡터의 구조 (24차원)

| 인덱스 | f의 요소 | 동역학 | 코드에서의 값 |
|--------|----------|--------|---------------|
| 0-2 | ṗ | dp/dt = v | `s.vel` |
| 3-5 | Ṙ 관련 | dR/dt ∝ ω - bg | `in.gyro - s.bg` |
| 6-8 | offset_Ṙ_L_I | 0 (상수) | 0 |
| 9-11 | offset_Ṫ_L_I | 0 (상수) | 0 |
| 12-14 | v̇ | dv/dt = R(a-ba) + g | `s.rot * (in.acc - s.ba) + s.grav` |
| 15-17 | ḃg | 0 (+ noise) | 0 |
| 18-20 | ḃa | 0 (+ noise) | 0 |
| 21-23 | ġ | 0 (상수) | 0 |

### F 행렬이란?

F는 **"상태 변화율 f가 상태 x에 얼마나 민감한가?"**를 나타내는 야코비 행렬.

```
F[i][j] = ∂f[i]/∂x[j] = ∂ẋ[i]/∂x[j]
```

예를 들어:
- ∂ṗ/∂vel = I → "위치 변화율이 속도에 얼마나 민감한가?" = 완전히 비례 (I)
- ∂Ṙ/∂bg = -I → "회전 변화율이 자이로 바이어스에 얼마나 민감한가?" = 반비례 (-I)

### 왜 F의 좌변에 dot(˙)이 붙는가?

F의 정의가 `F = ∂f/∂x = ∂ẋ/∂x`이기 때문:
- f의 0-2번째 성분 = ṗ (위치의 시간 변화율)
- f의 3-5번째 성분 = Ṙ 관련 (회전의 시간 변화율)
- f의 12-14번째 성분 = v̇ (속도의 시간 변화율)

dot이 없으면 의미가 완전히 달라짐:
- ∂ṗ/∂vel = "위치 **변화율**이 속도에 민감한가?" ✓
- ∂p/∂vel = "위치가 속도에 민감한가?" ✗ (다른 의미)

### 코드에서 f[3:6] = ω - bg로 설정하는 이유

동역학 식:
```
dR/dt = R · [ω - bg]×
```

실제 코드 (`get_f()` 함수):
```cpp
Eigen::Vector3d omega = in.gyro - s.bg;  // ω - bg
res(i + 3) = omega[i];                   // f[3:6] = ω - bg
```

F 행렬에서 ∂Ṙ/∂bg = -I가 되는 이유:
- ω는 **입력**(IMU 측정값)이므로 상태에 대해 미분하면 0
- bg는 **상태**이므로:
```
∂f[3:6]/∂bg = ∂(ω - bg)/∂bg = -I
```

### F 행렬의 역할

F는 **상태 업데이트에는 사용되지 않음**. 오직 **공분산(불확실성) 전파**에만 사용:

```
오차: δẋ = ẋ_true - ẋ_est ≈ F · δx
```

현재 상태 오차 δx가 있으면, 그 오차가 시간이 지나면서 어떻게 커지거나 작아지는지를 F가 알려줌.

---

## 2. Fw의 역할

### Fw란?

Fw는 **Input Jacobian Matrix** (24×12):
```
Fw = ∂f/∂w
```

**"입력 노이즈 w가 상태 변화율 f에 얼마나 영향을 주는가?"**를 나타냄.

### Fw 행렬 구조

```
Fw (24×12) =
      nw  na  nbg nba
p   [  0   0   0   0 ]
R   [ -I   0   0   0 ]  ← 각속도 노이즈가 회전에 영향
R_L [  0   0   0   0 ]
T_L [  0   0   0   0 ]
v   [  0  -R   0   0 ]  ← 가속도 노이즈가 속도에 영향
bg  [  0   0   I   0 ]  ← 바이어스 랜덤 워크
ba  [  0   0   0   I ]  ← 바이어스 랜덤 워크
g   [  0   0   0   0 ]
```

### Fw가 사용되는 곳: 공분산 전파

```cpp
void predict(double& dt, Eigen::Matrix<double, 12, 12>& Q, const input_ikfom& i_in) {
  // ...
  Eigen::Matrix<double, 24, 12> f_w_ = df_dw(x_, i_in);  // Fw 계산

  // 공분산 전파
  P_ = (f_x_) * P_ * (f_x_).transpose()
     + (dt * f_w_) * Q * (dt * f_w_).transpose();
  //   └────────────────────────────────┘
  //              Fw가 여기서 사용됨
}
```

### Fw의 핵심 역할

```
Q (12×12)  →  Fw (24×12)  →  상태 공분산 (24×24)
 입력 노이즈      매핑         불확실성 증가
```

- Q는 12차원 **입력 노이즈** (각속도, 가속도, 바이어스 노이즈)
- Fw는 이 노이즈가 **24차원 상태**에 어떻게 영향을 주는지 매핑
- `(Fw·dt)·Q·(Fw·dt)ᵀ`는 24×24 행렬이 되어 P에 더해짐

**요약**: Fw는 상태 업데이트에는 사용되지 않고, **공분산(불확실성) 전파**에만 사용됨.

---

## 3. 두 가지 노이즈 모델 비교

### 모델 1: Additive Noise Model (가산 노이즈 모델)

**특징:**
- 노이즈가 상태에 직접 더해짐
- Q가 상태와 같은 차원
- Fw가 필요 없음 (암묵적으로 I)

**공분산 전파:**
```
P' = A·P·Aᵀ + Q
```

**예시 코드:**
```cpp
// Q는 상태와 같은 3×3
Q << 0.0, 0.0, 0.0,
     0.0, 0.001, 0.0,
     0.0, 0.0, 0.001;

// 공분산 전파
P = A * P * A.transpose() + Q;  // Fw 없음
```

### 모델 2: Input Noise Model (입력 노이즈 모델)

**특징:**
- 노이즈가 입력(센서)에 있음
- Q가 입력 노이즈 차원 (상태보다 작을 수 있음)
- Fw가 노이즈를 상태 공간으로 매핑

**공분산 전파:**
```
P' = Φ·P·Φᵀ + (Fw·dt)·Q·(Fw·dt)ᵀ
```

**S-Faster-Lio 코드:**
```cpp
// Q는 입력 노이즈 차원 12×12
Q.block<3, 3>(0, 0) = 0.0001 * I;   // 각속도 노이즈
Q.block<3, 3>(3, 3) = 0.0001 * I;   // 가속도 노이즈
Q.block<3, 3>(6, 6) = 0.00001 * I;  // 자이로 바이어스 노이즈
Q.block<3, 3>(9, 9) = 0.00001 * I;  // 가속도 바이어스 노이즈

// 공분산 전파 - Fw로 매핑
P_ = f_x_ * P_ * f_x_.transpose()
   + (dt * f_w_) * Q * (dt * f_w_).transpose();
```

### 비교 표

| 항목 | Additive Model | Input Model (S-Faster-Lio) |
|------|----------------|---------------------------|
| Q의 의미 | 상태에 직접 더해지는 불확실성 | IMU 센서의 노이즈 |
| Q의 크기 | 상태 차원 (24×24) | 입력 노이즈 차원 (12×12) |
| Fw | 필요 없음 (=I) | 노이즈 → 상태 매핑 (24×12) |
| 장점 | 단순함 | 물리적 의미 명확, 노이즈 출처 추적 가능 |
| 단점 | 노이즈 출처 불명확 | 구현 복잡 |

### 왜 S-Faster-Lio는 Input Noise Model을 사용하는가?

1. **물리적 정확성**: 노이즈가 실제로 발생하는 곳(IMU 센서)을 명시적으로 모델링
2. **유연성**: 각 노이즈 소스(각속도, 가속도, 바이어스)를 독립적으로 튜닝 가능
3. **차원 효율성**: Q가 12×12로 24×24보다 작음

---

## 요약

1. **f와 F의 관계**:
   - f = 상태의 시간 변화율 (ẋ)
   - F = ∂f/∂x = f가 상태에 얼마나 민감한지 (야코비)
   - F의 좌변에 dot이 붙는 이유: F = ∂ẋ/∂x 이므로

2. **Fw의 역할**:
   - 입력 노이즈가 상태에 미치는 영향을 매핑
   - 공분산 전파에서만 사용 (상태 업데이트에는 사용 안 함)
   - `(Fw·dt)·Q·(Fw·dt)ᵀ`로 노이즈 기여분 계산

3. **두 노이즈 모델**:
   - Additive: Q가 상태 차원, Fw 불필요
   - Input (S-Faster-Lio): Q가 입력 차원, Fw로 매핑
